<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/service/CarteService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/service/CarteService.java" />
              <option name="originalContent" value="package service;&#10;&#10;import dao.CardDAO;&#10;import entity.*;&#10;import entity.enums.CardStatus;&#10;&#10;import java.math.BigDecimal;&#10;import java.sql.SQLException;&#10;import java.time.LocalDate;&#10;import java.util.List;&#10;import java.util.Optional;&#10;import java.util.Random;&#10;&#10;public class CarteService {&#10;    private final CardDAO cardDAO;&#10;    private final Random random;&#10;&#10;    public CarteService() {&#10;        this.cardDAO = new CardDAO();&#10;        this.random = new Random();&#10;    }&#10;&#10;    // Generate unique card number&#10;    private String generateCardNumber() {&#10;        StringBuilder number = new StringBuilder();&#10;        for (int i = 0; i &lt; 16; i++) {&#10;            number.append(random.nextInt(10));&#10;        }&#10;        return number.toString();&#10;    }&#10;&#10;    // Create debit card&#10;    public DebitCard createDebitCard(int customerId, BigDecimal dailyLimit) throws SQLException {&#10;        String number = generateCardNumber();&#10;        LocalDate expiration = LocalDate.now().plusYears(3);&#10;&#10;        DebitCard card = new DebitCard(0, number, expiration, CardStatus.ACTIVE, customerId, dailyLimit);&#10;        return (DebitCard) cardDAO.save(card);&#10;    }&#10;&#10;    // Create credit card&#10;    public CreditCard createCreditCard(int customerId, BigDecimal creditLimit, BigDecimal interestRate) throws SQLException {&#10;        String number = generateCardNumber();&#10;        LocalDate expiration = LocalDate.now().plusYears(3);&#10;&#10;        CreditCard card = new CreditCard(0, number, expiration, CardStatus.ACTIVE, customerId, creditLimit, interestRate);&#10;        return (CreditCard) cardDAO.save(card);&#10;    }&#10;&#10;    // Create prepaid card&#10;    public PrepaidCard createPrepaidCard(int customerId, BigDecimal initialBalance) throws SQLException {&#10;        String number = generateCardNumber();&#10;        LocalDate expiration = LocalDate.now().plusYears(3);&#10;&#10;        PrepaidCard card = new PrepaidCard(0, number, expiration, CardStatus.ACTIVE, customerId, initialBalance);&#10;        return (PrepaidCard) cardDAO.save(card);&#10;    }&#10;&#10;    // Activate card&#10;    public boolean activateCard(int cardId) throws SQLException {&#10;        Optional&lt;Card&gt; cardOpt = cardDAO.findById(cardId);&#10;        if (cardOpt.isEmpty()) {&#10;            throw new IllegalArgumentException(&quot;Card not found&quot;);&#10;        }&#10;&#10;        Card card = cardOpt.get();&#10;        if (card.getStatus() == CardStatus.ACTIVE) {&#10;            throw new IllegalStateException(&quot;Card is already active&quot;);&#10;        }&#10;&#10;        card.setStatus(CardStatus.ACTIVE);&#10;        return cardDAO.update(card);&#10;    }&#10;&#10;    // Suspend card&#10;    public boolean suspendCard(int cardId) throws SQLException {&#10;        Optional&lt;Card&gt; cardOpt = cardDAO.findById(cardId);&#10;        if (cardOpt.isEmpty()) {&#10;            throw new IllegalArgumentException(&quot;Card not found&quot;);&#10;        }&#10;&#10;        Card card = cardOpt.get();&#10;        card.setStatus(CardStatus.SUSPENDED);&#10;        return cardDAO.update(card);&#10;    }&#10;&#10;    // Block card&#10;    public boolean blockCard(int cardId) throws SQLException {&#10;        Optional&lt;Card&gt; cardOpt = cardDAO.findById(cardId);&#10;        if (cardOpt.isEmpty()) {&#10;            throw new IllegalArgumentException(&quot;Card not found&quot;);&#10;        }&#10;&#10;        Card card = cardOpt.get();&#10;        card.setStatus(CardStatus.BLOCKED);&#10;        return cardDAO.update(card);&#10;    }&#10;&#10;    // Verify if operation is within limit&#10;    public boolean verifyLimit(int cardId, BigDecimal amount) throws SQLException {&#10;        Optional&lt;Card&gt; cardOpt = cardDAO.findById(cardId);&#10;        if (cardOpt.isEmpty()) {&#10;            throw new IllegalArgumentException(&quot;Card not found&quot;);&#10;        }&#10;&#10;        Card card = cardOpt.get();&#10;&#10;        if (card instanceof DebitCard) {&#10;            DebitCard debitCard = (DebitCard) card;&#10;            return amount.compareTo(debitCard.getDailyLimit()) &lt;= 0;&#10;        } else if (card instanceof CreditCard) {&#10;            CreditCard creditCard = (CreditCard) card;&#10;            return amount.compareTo(creditCard.getCreditLimit()) &lt;= 0;&#10;        } else if (card instanceof PrepaidCard) {&#10;            PrepaidCard prepaidCard = (PrepaidCard) card;&#10;            return amount.compareTo(prepaidCard.getBalance()) &lt;= 0;&#10;        }&#10;&#10;        return false;&#10;    }&#10;&#10;    // Get card by ID&#10;    public Optional&lt;Card&gt; findCardById(int cardId) throws SQLException {&#10;        return cardDAO.findById(cardId);&#10;    }&#10;&#10;    // Get cards by customer&#10;    public List&lt;Card&gt; findCardsByCustomer(int customerId) throws SQLException {&#10;        return cardDAO.findByCustomerId(customerId);&#10;    }&#10;&#10;    // Get all cards&#10;    public List&lt;Card&gt; findAllCards() throws SQLException {&#10;        return cardDAO.findAll();&#10;    }&#10;&#10;    // Update card&#10;    public boolean updateCard(Card card) throws SQLException {&#10;        return cardDAO.update(card);&#10;    }&#10;&#10;    // Delete card&#10;    public boolean deleteCard(int cardId) throws SQLException {&#10;        return cardDAO.delete(cardId);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package service;&#10;&#10;import dao.CardDAO;&#10;import entity.*;&#10;import entity.enums.CardStatus;&#10;&#10;import java.math.BigDecimal;&#10;import java.sql.SQLException;&#10;import java.time.LocalDate;&#10;import java.util.List;&#10;import java.util.Optional;&#10;import java.util.Random;&#10;&#10;public class CardService {&#10;    private final CardDAO cardDAO;&#10;    private final Random random;&#10;&#10;    public CardService() {&#10;        this.cardDAO = new CardDAO();&#10;        this.random = new Random();&#10;    }&#10;&#10;    // Generate unique card number&#10;    private String generateCardNumber() {&#10;        StringBuilder number = new StringBuilder();&#10;        for (int i = 0; i &lt; 16; i++) {&#10;            number.append(random.nextInt(10));&#10;        }&#10;        return number.toString();&#10;    }&#10;&#10;    // Create debit card&#10;    public DebitCard createDebitCard(int customerId, BigDecimal dailyLimit) throws SQLException {&#10;        String number = generateCardNumber();&#10;        LocalDate expiration = LocalDate.now().plusYears(3);&#10;&#10;        DebitCard card = new DebitCard(0, number, expiration, CardStatus.ACTIVE, customerId, dailyLimit);&#10;        return (DebitCard) cardDAO.save(card);&#10;    }&#10;&#10;    // Create credit card&#10;    public CreditCard createCreditCard(int customerId, BigDecimal creditLimit, BigDecimal interestRate) throws SQLException {&#10;        String number = generateCardNumber();&#10;        LocalDate expiration = LocalDate.now().plusYears(3);&#10;&#10;        CreditCard card = new CreditCard(0, number, expiration, CardStatus.ACTIVE, customerId, creditLimit, interestRate);&#10;        return (CreditCard) cardDAO.save(card);&#10;    }&#10;&#10;    // Create prepaid card&#10;    public PrepaidCard createPrepaidCard(int customerId, BigDecimal initialBalance) throws SQLException {&#10;        String number = generateCardNumber();&#10;        LocalDate expiration = LocalDate.now().plusYears(3);&#10;&#10;        PrepaidCard card = new PrepaidCard(0, number, expiration, CardStatus.ACTIVE, customerId, initialBalance);&#10;        return (PrepaidCard) cardDAO.save(card);&#10;    }&#10;&#10;    // Activate card&#10;    public boolean activateCard(int cardId) throws SQLException {&#10;        Optional&lt;Card&gt; cardOpt = cardDAO.findById(cardId);&#10;        if (cardOpt.isEmpty()) {&#10;            throw new IllegalArgumentException(&quot;Card not found&quot;);&#10;        }&#10;&#10;        Card card = cardOpt.get();&#10;        if (card.getStatus() == CardStatus.ACTIVE) {&#10;            throw new IllegalStateException(&quot;Card is already active&quot;);&#10;        }&#10;&#10;        card.setStatus(CardStatus.ACTIVE);&#10;        return cardDAO.update(card);&#10;    }&#10;&#10;    // Suspend card&#10;    public boolean suspendCard(int cardId) throws SQLException {&#10;        Optional&lt;Card&gt; cardOpt = cardDAO.findById(cardId);&#10;        if (cardOpt.isEmpty()) {&#10;            throw new IllegalArgumentException(&quot;Card not found&quot;);&#10;        }&#10;&#10;        Card card = cardOpt.get();&#10;        card.setStatus(CardStatus.SUSPENDED);&#10;        return cardDAO.update(card);&#10;    }&#10;&#10;    // Block card&#10;    public boolean blockCard(int cardId) throws SQLException {&#10;        Optional&lt;Card&gt; cardOpt = cardDAO.findById(cardId);&#10;        if (cardOpt.isEmpty()) {&#10;            throw new IllegalArgumentException(&quot;Card not found&quot;);&#10;        }&#10;&#10;        Card card = cardOpt.get();&#10;        card.setStatus(CardStatus.BLOCKED);&#10;        return cardDAO.update(card);&#10;    }&#10;&#10;    // Verify if operation is within limit&#10;    public boolean verifyLimit(int cardId, BigDecimal amount) throws SQLException {&#10;        Optional&lt;Card&gt; cardOpt = cardDAO.findById(cardId);&#10;        if (cardOpt.isEmpty()) {&#10;            throw new IllegalArgumentException(&quot;Card not found&quot;);&#10;        }&#10;&#10;        Card card = cardOpt.get();&#10;&#10;        if (card instanceof DebitCard) {&#10;            DebitCard debitCard = (DebitCard) card;&#10;            return amount.compareTo(debitCard.getDailyLimit()) &lt;= 0;&#10;        } else if (card instanceof CreditCard) {&#10;            CreditCard creditCard = (CreditCard) card;&#10;            return amount.compareTo(creditCard.getCreditLimit()) &lt;= 0;&#10;        } else if (card instanceof PrepaidCard) {&#10;            PrepaidCard prepaidCard = (PrepaidCard) card;&#10;            return amount.compareTo(prepaidCard.getBalance()) &lt;= 0;&#10;        }&#10;&#10;        return false;&#10;    }&#10;&#10;    // Get card by ID&#10;    public Optional&lt;Card&gt; findCardById(int cardId) throws SQLException {&#10;        return cardDAO.findById(cardId);&#10;    }&#10;&#10;    // Get cards by customer&#10;    public List&lt;Card&gt; findCardsByCustomer(int customerId) throws SQLException {&#10;        return cardDAO.findByCustomerId(customerId);&#10;    }&#10;&#10;    // Get all cards&#10;    public List&lt;Card&gt; findAllCards() throws SQLException {&#10;        return cardDAO.findAll();&#10;    }&#10;&#10;    // Update card&#10;    public boolean updateCard(Card card) throws SQLException {&#10;        return cardDAO.update(card);&#10;    }&#10;&#10;    // Delete card&#10;    public boolean deleteCard(int cardId) throws SQLException {&#10;        return cardDAO.delete(cardId);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/service/ClientService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/service/ClientService.java" />
              <option name="originalContent" value="package service;&#10;&#10;import dao.CustomerDAO;&#10;import entity.Customer;&#10;&#10;import java.sql.SQLException;&#10;import java.util.List;&#10;import java.util.Optional;&#10;&#10;public class ClientService {&#10;    private final CustomerDAO customerDAO;&#10;&#10;    public ClientService() {&#10;        this.customerDAO = new CustomerDAO();&#10;    }&#10;&#10;    // Create customer&#10;    public Customer createCustomer(String name, String email, String phone) throws SQLException {&#10;        // Validate email uniqueness&#10;        Optional&lt;Customer&gt; existing = customerDAO.findByEmail(email);&#10;        if (existing.isPresent()) {&#10;            throw new IllegalArgumentException(&quot;A customer with this email already exists&quot;);&#10;        }&#10;&#10;        Customer customer = new Customer(0, name, email, phone);&#10;        return customerDAO.save(customer);&#10;    }&#10;&#10;    // Get customer by ID&#10;    public Optional&lt;Customer&gt; findCustomerById(int id) throws SQLException {&#10;        return customerDAO.findById(id);&#10;    }&#10;&#10;    // Get customer by email&#10;    public Optional&lt;Customer&gt; findCustomerByEmail(String email) throws SQLException {&#10;        return customerDAO.findByEmail(email);&#10;    }&#10;&#10;    // Get all customers&#10;    public List&lt;Customer&gt; findAllCustomers() throws SQLException {&#10;        return customerDAO.findAll();&#10;    }&#10;&#10;    // Update customer&#10;    public boolean updateCustomer(Customer customer) throws SQLException {&#10;        return customerDAO.update(customer);&#10;    }&#10;&#10;    // Delete customer&#10;    public boolean deleteCustomer(int id) throws SQLException {&#10;        return customerDAO.delete(id);&#10;    }&#10;&#10;    // Search customers by name&#10;    public List&lt;Customer&gt; searchCustomersByName(String name) throws SQLException {&#10;        return customerDAO.searchByName(name);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package service;&#10;&#10;import dao.CustomerDAO;&#10;import entity.Customer;&#10;&#10;import java.sql.SQLException;&#10;import java.util.List;&#10;import java.util.Optional;&#10;&#10;public class CustomerService {&#10;    private final CustomerDAO customerDAO;&#10;&#10;    public CustomerService() {&#10;        this.customerDAO = new CustomerDAO();&#10;    }&#10;&#10;    // Create customer&#10;    public Customer createCustomer(String name, String email, String phone) throws SQLException {&#10;        // Validate email uniqueness&#10;        Optional&lt;Customer&gt; existing = customerDAO.findByEmail(email);&#10;        if (existing.isPresent()) {&#10;            throw new IllegalArgumentException(&quot;A customer with this email already exists&quot;);&#10;        }&#10;&#10;        Customer customer = new Customer(0, name, email, phone);&#10;        return customerDAO.save(customer);&#10;    }&#10;&#10;    // Get customer by ID&#10;    public Optional&lt;Customer&gt; findCustomerById(int id) throws SQLException {&#10;        return customerDAO.findById(id);&#10;    }&#10;&#10;    // Get customer by email&#10;    public Optional&lt;Customer&gt; findCustomerByEmail(String email) throws SQLException {&#10;        return customerDAO.findByEmail(email);&#10;    }&#10;&#10;    // Get all customers&#10;    public List&lt;Customer&gt; findAllCustomers() throws SQLException {&#10;        return customerDAO.findAll();&#10;    }&#10;&#10;    // Update customer&#10;    public boolean updateCustomer(Customer customer) throws SQLException {&#10;        return customerDAO.update(customer);&#10;    }&#10;&#10;    // Delete customer&#10;    public boolean deleteCustomer(int id) throws SQLException {&#10;        return customerDAO.delete(id);&#10;    }&#10;&#10;    // Search customers by name&#10;    public List&lt;Customer&gt; searchCustomersByName(String name) throws SQLException {&#10;        return customerDAO.searchByName(name);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/service/FraudeService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/service/FraudeService.java" />
              <option name="originalContent" value="package service;&#10;&#10;import dao.CardOperationDAO;&#10;import dao.FraudAlertDAO;&#10;import entity.FraudAlert;&#10;import entity.CardOperation;&#10;import entity.enums.AlertLevel;&#10;&#10;import java.math.BigDecimal;&#10;import java.sql.SQLException;&#10;import java.time.Duration;&#10;import java.time.LocalDateTime;&#10;import java.util.List;&#10;&#10;public class FraudeService {&#10;    private final CardOperationDAO operationDAO;&#10;    private final FraudAlertDAO alertDAO;&#10;    private final CarteService carteService;&#10;&#10;    // Fraud detection thresholds&#10;    private static final BigDecimal SUSPICIOUS_AMOUNT = new BigDecimal(&quot;5000&quot;);&#10;    private static final long SUSPICIOUS_OPERATION_MINUTES = 30;&#10;&#10;    public FraudeService() {&#10;        this.operationDAO = new CardOperationDAO();&#10;        this.alertDAO = new FraudAlertDAO();&#10;        this.carteService = new CarteService();&#10;    }&#10;&#10;    // Main fraud detection method&#10;    public void detectFraud(int cardId) throws SQLException {&#10;        List&lt;CardOperation&gt; operations = operationDAO.findByCardId(cardId);&#10;&#10;        if (operations.isEmpty()) {&#10;            return;&#10;        }&#10;&#10;        // Check for high amount transactions&#10;        detectHighAmountTransactions(operations);&#10;&#10;        // Check for rapid transactions in different locations&#10;        detectRapidTransactions(operations);&#10;&#10;        // Check for multiple failed attempts&#10;        detectMultipleAttempts(operations);&#10;    }&#10;&#10;    // Detect high amount transactions&#10;    private void detectHighAmountTransactions(List&lt;CardOperation&gt; operations) throws SQLException {&#10;        for (CardOperation op : operations) {&#10;            if (op.getAmount().compareTo(SUSPICIOUS_AMOUNT) &gt; 0) {&#10;                String description = String.format(&#10;                    &quot;High amount detected: %.2f EUR at %s on %s&quot;,&#10;                    op.getAmount(),&#10;                    op.getLocation(),&#10;                    op.getOperationDate()&#10;                );&#10;                createAlert(op.getCardId(), description, AlertLevel.WARNING);&#10;            }&#10;        }&#10;    }&#10;&#10;    // Detect rapid transactions in different locations&#10;    private void detectRapidTransactions(List&lt;CardOperation&gt; operations) throws SQLException {&#10;        for (int i = 0; i &lt; operations.size() - 1; i++) {&#10;            CardOperation op1 = operations.get(i);&#10;            CardOperation op2 = operations.get(i + 1);&#10;&#10;            // Calculate time difference&#10;            Duration duration = Duration.between(op2.getOperationDate(), op1.getOperationDate());&#10;            long minutesDiff = Math.abs(duration.toMinutes());&#10;&#10;            // Check if operations are close in time but in different locations&#10;            if (minutesDiff &lt;= SUSPICIOUS_OPERATION_MINUTES &amp;&amp; !op1.getLocation().equals(op2.getLocation())) {&#10;                String description = String.format(&#10;                    &quot;Suspicious operations: %s at %s and %s at %s within %d minutes&quot;,&#10;                    op1.getLocation(),&#10;                    op1.getOperationDate(),&#10;                    op2.getLocation(),&#10;                    op2.getOperationDate(),&#10;                    minutesDiff&#10;                );&#10;                createAlert(op1.getCardId(), description, AlertLevel.CRITICAL);&#10;&#10;                // Block the card automatically for critical fraud&#10;                carteService.blockCard(op1.getCardId());&#10;            }&#10;        }&#10;    }&#10;&#10;    // Detect multiple transactions in short time (potential attack)&#10;    private void detectMultipleAttempts(List&lt;CardOperation&gt; operations) throws SQLException {&#10;        if (operations.size() &lt; 5) {&#10;            return;&#10;        }&#10;&#10;        // Check if there are 5+ operations within 1 hour&#10;        for (int i = 0; i &lt; operations.size() - 4; i++) {&#10;            CardOperation first = operations.get(i);&#10;            CardOperation fifth = operations.get(i + 4);&#10;&#10;            Duration duration = Duration.between(fifth.getOperationDate(), first.getOperationDate());&#10;            long minutesDiff = Math.abs(duration.toMinutes());&#10;&#10;            if (minutesDiff &lt;= 60) {&#10;                String description = String.format(&#10;                    &quot;Multiple attempts detected: 5+ operations in %d minutes&quot;,&#10;                    minutesDiff&#10;                );&#10;                createAlert(first.getCardId(), description, AlertLevel.CRITICAL);&#10;                carteService.suspendCard(first.getCardId());&#10;            }&#10;        }&#10;    }&#10;&#10;    // Create fraud alert&#10;    public FraudAlert createAlert(int cardId, String description, AlertLevel level) throws SQLException {&#10;        FraudAlert alert = new FraudAlert(&#10;            0,&#10;            description,&#10;            level,&#10;            cardId,&#10;            LocalDateTime.now()&#10;        );&#10;        return alertDAO.save(alert);&#10;    }&#10;&#10;    // Get alerts by card&#10;    public List&lt;FraudAlert&gt; getAlertsByCard(int cardId) throws SQLException {&#10;        return alertDAO.findByCardId(cardId);&#10;    }&#10;&#10;    // Get all alerts&#10;    public List&lt;FraudAlert&gt; getAllAlerts() throws SQLException {&#10;        return alertDAO.findAll();&#10;    }&#10;&#10;    // Get critical alerts&#10;    public List&lt;FraudAlert&gt; getCriticalAlerts() throws SQLException {&#10;        return alertDAO.findCriticalAlerts();&#10;    }&#10;&#10;    // Get alerts by level&#10;    public List&lt;FraudAlert&gt; getAlertsByLevel(AlertLevel level) throws SQLException {&#10;        return alertDAO.findByLevel(level);&#10;    }&#10;&#10;    // Delete alert&#10;    public boolean deleteAlert(int id) throws SQLException {&#10;        return alertDAO.delete(id);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package service;&#10;&#10;import dao.CardOperationDAO;&#10;import dao.FraudAlertDAO;&#10;import entity.FraudAlert;&#10;import entity.CardOperation;&#10;import entity.enums.AlertLevel;&#10;&#10;import java.math.BigDecimal;&#10;import java.sql.SQLException;&#10;import java.time.Duration;&#10;import java.time.LocalDateTime;&#10;import java.util.List;&#10;&#10;public class FraudService {&#10;    private final CardOperationDAO operationDAO;&#10;    private final FraudAlertDAO alertDAO;&#10;    private final CardService cardService;&#10;&#10;    // Fraud detection thresholds&#10;    private static final BigDecimal SUSPICIOUS_AMOUNT = new BigDecimal(&quot;5000&quot;);&#10;    private static final long SUSPICIOUS_OPERATION_MINUTES = 30;&#10;&#10;    public FraudService() {&#10;        this.operationDAO = new CardOperationDAO();&#10;        this.alertDAO = new FraudAlertDAO();&#10;        this.cardService = new CardService();&#10;    }&#10;&#10;    // Main fraud detection method&#10;    public void detectFraud(int cardId) throws SQLException {&#10;        List&lt;CardOperation&gt; operations = operationDAO.findByCardId(cardId);&#10;&#10;        if (operations.isEmpty()) {&#10;            return;&#10;        }&#10;&#10;        // Check for high amount transactions&#10;        detectHighAmountTransactions(operations);&#10;&#10;        // Check for rapid transactions in different locations&#10;        detectRapidTransactions(operations);&#10;&#10;        // Check for multiple failed attempts&#10;        detectMultipleAttempts(operations);&#10;    }&#10;&#10;    // Detect high amount transactions&#10;    private void detectHighAmountTransactions(List&lt;CardOperation&gt; operations) throws SQLException {&#10;        for (CardOperation op : operations) {&#10;            if (op.getAmount().compareTo(SUSPICIOUS_AMOUNT) &gt; 0) {&#10;                String description = String.format(&#10;                    &quot;High amount detected: %.2f EUR at %s on %s&quot;,&#10;                    op.getAmount(),&#10;                    op.getLocation(),&#10;                    op.getOperationDate()&#10;                );&#10;                createAlert(op.getCardId(), description, AlertLevel.WARNING);&#10;            }&#10;        }&#10;    }&#10;&#10;    // Detect rapid transactions in different locations&#10;    private void detectRapidTransactions(List&lt;CardOperation&gt; operations) throws SQLException {&#10;        for (int i = 0; i &lt; operations.size() - 1; i++) {&#10;            CardOperation op1 = operations.get(i);&#10;            CardOperation op2 = operations.get(i + 1);&#10;&#10;            // Calculate time difference&#10;            Duration duration = Duration.between(op2.getOperationDate(), op1.getOperationDate());&#10;            long minutesDiff = Math.abs(duration.toMinutes());&#10;&#10;            // Check if operations are close in time but in different locations&#10;            if (minutesDiff &lt;= SUSPICIOUS_OPERATION_MINUTES &amp;&amp; !op1.getLocation().equals(op2.getLocation())) {&#10;                String description = String.format(&#10;                    &quot;Suspicious operations: %s at %s and %s at %s within %d minutes&quot;,&#10;                    op1.getLocation(),&#10;                    op1.getOperationDate(),&#10;                    op2.getLocation(),&#10;                    op2.getOperationDate(),&#10;                    minutesDiff&#10;                );&#10;                createAlert(op1.getCardId(), description, AlertLevel.CRITICAL);&#10;&#10;                // Block the card automatically for critical fraud&#10;                cardService.blockCard(op1.getCardId());&#10;            }&#10;        }&#10;    }&#10;&#10;    // Detect multiple transactions in short time (potential attack)&#10;    private void detectMultipleAttempts(List&lt;CardOperation&gt; operations) throws SQLException {&#10;        if (operations.size() &lt; 5) {&#10;            return;&#10;        }&#10;&#10;        // Check if there are 5+ operations within 1 hour&#10;        for (int i = 0; i &lt; operations.size() - 4; i++) {&#10;            CardOperation first = operations.get(i);&#10;            CardOperation fifth = operations.get(i + 4);&#10;&#10;            Duration duration = Duration.between(fifth.getOperationDate(), first.getOperationDate());&#10;            long minutesDiff = Math.abs(duration.toMinutes());&#10;&#10;            if (minutesDiff &lt;= 60) {&#10;                String description = String.format(&#10;                    &quot;Multiple attempts detected: 5+ operations in %d minutes&quot;,&#10;                    minutesDiff&#10;                );&#10;                createAlert(first.getCardId(), description, AlertLevel.CRITICAL);&#10;                cardService.suspendCard(first.getCardId());&#10;            }&#10;        }&#10;    }&#10;&#10;    // Create fraud alert&#10;    public FraudAlert createAlert(int cardId, String description, AlertLevel level) throws SQLException {&#10;        FraudAlert alert = new FraudAlert(&#10;            0,&#10;            description,&#10;            level,&#10;            cardId,&#10;            LocalDateTime.now()&#10;        );&#10;        return alertDAO.save(alert);&#10;    }&#10;&#10;    // Get alerts by card&#10;    public List&lt;FraudAlert&gt; getAlertsByCard(int cardId) throws SQLException {&#10;        return alertDAO.findByCardId(cardId);&#10;    }&#10;&#10;    // Get all alerts&#10;    public List&lt;FraudAlert&gt; getAllAlerts() throws SQLException {&#10;        return alertDAO.findAll();&#10;    }&#10;&#10;    // Get critical alerts&#10;    public List&lt;FraudAlert&gt; getCriticalAlerts() throws SQLException {&#10;        return alertDAO.findCriticalAlerts();&#10;    }&#10;&#10;    // Get alerts by level&#10;    public List&lt;FraudAlert&gt; getAlertsByLevel(AlertLevel level) throws SQLException {&#10;        return alertDAO.findByLevel(level);&#10;    }&#10;&#10;    // Delete alert&#10;    public boolean deleteAlert(int id) throws SQLException {&#10;        return alertDAO.delete(id);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>